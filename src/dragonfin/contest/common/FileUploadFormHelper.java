package dragonfin.contest.common;

import java.io.*;
import java.util.*;
import javax.servlet.*;
import javax.servlet.http.*;
import org.apache.commons.fileupload.*;
import org.apache.commons.fileupload.servlet.ServletFileUpload;
import java.nio.charset.Charset;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import com.google.appengine.api.datastore.*;
import java.util.logging.Logger;

import static dragonfin.contest.common.CommonFunctions.byteArray2Hex;
import static dragonfin.contest.common.CommonFunctions.escapeUrl;

public class FileUploadFormHelper
{
	private static final Logger log = Logger.getLogger(
			FileUploadFormHelper.class.getName());
	static final Charset UTF8 = Charset.forName("UTF-8");

	static String readStream(InputStream in)
		throws IOException
	{
		ByteArrayOutputStream bytes = new ByteArrayOutputStream();
		int nread;
		byte[] buf = new byte[8192];
		while ( (nread = in.read(buf)) != -1) {
			bytes.write(buf, 0, nread);
		}

		return new String(bytes.toByteArray(), UTF8);
	}

	static class UploadHelper
	{
		//maximum entity size is 1MB, this should keep us well under that
		// limit.
		// Watch out- changing these numbers will change hashing for files
		// of more than one chunk, which will break file equality checks.
		static final int MAX_CHUNK_SIZE = 128*1024;
		static final int MAX_BRANCHES = 64;

		DatastoreService ds;
		InputStream stream;
		byte [] buf = new byte[MAX_CHUNK_SIZE];

		int chunkCount = 0;
		long fileLen = 0;

		static MessageDigest createDigestObject()
		{
			try {
				return MessageDigest.getInstance("SHA-1");
			}
			catch (NoSuchAlgorithmException e) {
				throw new Error("Unexpected "+e.getMessage(), e);
			}
		}

		MessageDigest md = createDigestObject();

		FilePart nextChunk()
			throws IOException
		{
			int off = 0;
			while (off < buf.length)
			{
				int nread = stream.read(buf, off, buf.length-off);
				if (nread == -1) {
					break;
				}
				off += nread;
			}

			if (off == 0) {
				return null;
			}

			chunkCount++;
			fileLen += off;

			FilePart p = new FilePart();
			p.data = Arrays.copyOfRange(buf, 0, off);
			makeDigest(p);
			return p;
		}

		void makeDigest(FilePart p)
		{
			md.update(p.data);
			byte [] digestBytes = md.digest();
			p.digestHex = byteArray2Hex(digestBytes);
		}

		/**
		 * @return key of head chunk generated by input stream.
		 */
		Key processStream(InputStream stream)
			throws IOException
		{
			this.stream = stream;

			ChunkLayer leafs = new ChunkLayer();

			FilePart p;
			while ( (p = nextChunk()) != null )
			{
				Key chunkKey = KeyFactory.createKey("FileChunk", p.digestHex);
				Entity ent = new Entity(chunkKey);
				ent.setProperty("last_touched", new Date());
				ent.setProperty("data", new Blob(p.data));
				ds.put(ent);

				leafs.add(chunkKey);
			}

			return leafs.getRoot();
		}

		class ChunkLayer
		{
			ArrayList<Key> chunks = new ArrayList<Key>();
			ChunkLayer parent;
			int depth;

			void add(Key chunk)
			{
				if (chunks.size() >= MAX_BRANCHES) {
					requireParent();
					Key myKey = uploadChunkIndex(this);
					parent.add(myKey);
					chunks.clear();
				}
				chunks.add(chunk);
			}

			void requireParent()
			{
				if (parent == null) {
					parent = new ChunkLayer();
					parent.depth = this.depth+1;
				}
			}

			Key getRoot()
			{
				if (parent == null && chunks.size() == 1) {
					return chunks.get(0);
				}

				Key myKey = uploadChunkIndex(this);
				if (parent == null) {
					return myKey;
				}
				else {
					parent.add(myKey);
					return parent.getRoot();
				}
			}
		}

		Key uploadChunkIndex(ChunkLayer idx)
		{
			for (Key ch : idx.chunks) {
				String name = ch.getName();
				md.update(name.getBytes(UTF8));
			}
			byte [] digestBytes = md.digest();
			String digestHex = byteArray2Hex(digestBytes);

			Key idxKey = KeyFactory.createKey("FileChunk", digestHex+"-idx-"+idx.depth);
			Entity ent = new Entity(idxKey);
			ent.setProperty("last_touched", new Date());
			ent.setProperty("parts", idx.chunks);
			ds.put(ent);

			return idxKey;
		}
	}

	static class FilePart
	{
		byte [] data;
		String digestHex;
	}

	File handleFileUpload(HttpServletRequest req, FileItemStream item)
		throws ServletException, IOException
	{
		String fileName = item.getName();
		String contentType = item.getContentType();

		if (fileName == null || fileName.equals("")) {
			return null;
		}

		if (contentType == null || contentType.equals("")) {
			contentType = "text/plain";
		}

		InputStream stream = item.openStream();

		int colonSep = item.getFieldName().indexOf(':');
		if (colonSep != -1) {
			String options = item.getFieldName().substring(colonSep+1);
			if (options.equals("text")) {

				stream = new PlainTextFilter(stream);
			}
			else {

				log.warning("Invalid file upload options: "+item.getFieldName());
			}
		}

		return finishFileUpload(req, stream, fileName, contentType);
	}

	private File finishFileUpload(HttpServletRequest req, InputStream stream, String fileName, String contentType)
		throws IOException
	{
		UploadHelper helper = new UploadHelper();
		helper.ds = DatastoreServiceFactory.getDatastoreService();

		Key headChunk = helper.processStream(stream);

		helper.md.reset();
		helper.md.update(fileName.getBytes(UTF8));
		helper.md.update((byte)0);
		helper.md.update(contentType.getBytes(UTF8));
		helper.md.update((byte)0);
		helper.md.update(headChunk.getName().getBytes(UTF8));

		byte[] digestBytes = helper.md.digest();
		String digestHex = byteArray2Hex(digestBytes);

		Key fileKey = KeyFactory.createKey("File", digestHex);
		Entity ent = new Entity(fileKey);

		ent.setProperty("uploaded", new Date());
		ent.setProperty("given_name", fileName);
		ent.setProperty("content_type", contentType);

		ent.setProperty("head_chunk", headChunk);
		
		helper.ds.put(ent);

		File f = new File(req);
		f.id = digestHex;
		f.name = fileName;
		return f;
	}

	File convertTextToFile(HttpServletRequest req, String textContent, String fileName)
		throws IOException
	{
		ByteArrayInputStream bytes = new ByteArrayInputStream(
				textContent.getBytes(UTF8)
			);
		return finishFileUpload(req, bytes, fileName, "text/plain");
	}

	public class FormData extends HashMap<String,String>
	{
		final HttpServletRequest req;

		FormData(HttpServletRequest req)
		{
			this.req = req;
		}

		public File handleFileContent(String fieldName)
			throws IOException
		{
			//
			// if the user provided a file in the file-upload control,
			// that's the file we return.
			//
			if (containsKey(fieldName+"_upload") && containsKey(fieldName+"_upload.name")) {
				// already got a file
				return getFile(fieldName);
			}

			//
			// if the user provided content in a file-content textarea,
			// we convert it to a text/plain file and return that.
			//
			String contentString = get(fieldName+"_content");
			if (contentString != null && contentString.length() != 0) {

				String fileName = get(fieldName+"_name");
				if (fileName == null) {
					// generate an appropriate file name
					fileName = fieldName+".txt";
				}

				File f = convertTextToFile(req, contentString, fileName);

				put(fieldName+"_upload", f.id);
				put(fieldName+"_upload.name", f.name);
				return f;
			}

			//
			// if the user provided a file hash reference in a hidden
			// control, return that.
			//
			String fileHashRef = get(fieldName+"_file");
			if (fileHashRef != null && fileHashRef.length() != 0) {

				String fileName = get(fieldName+"_name");
				if (fileName == null) {
					// generate an appropriate file name
					fileName = fieldName+".txt";
				}

				File f = new File(req);
				f.id = fileHashRef;
				f.name = fileName;

				put(fieldName+"_upload", f.id);
				put(fieldName+"_upload.name", f.name);
				return f;
			}

			return null;
		}

		public File getFile(String fieldName)
			throws IOException
		{
			if (containsKey(fieldName+"_upload") && containsKey(fieldName+"_upload.name")) {
				File f = new File(req);
				f.id = get(fieldName+"_upload");
				f.name = get(fieldName+"_upload.name");
				return f;
			}
			else {
				return null;
			}
		}
	}

	public FormData processMultipartForm(HttpServletRequest req)
		throws ServletException, IOException
	{
		try {

		FormData formFields = new FormData(req);

		ServletFileUpload upload = new ServletFileUpload();
		FileItemIterator it = upload.getItemIterator(req);
		while (it.hasNext()) {
			FileItemStream item = it.next();

			if (item.isFormField()) {
				String name = item.getFieldName();
				String value = readStream(item.openStream());
				formFields.put(name, value);
			}
			else {
				String name = item.getFieldName();
				if (name.indexOf(':') != -1) {
					name = name.substring(0, name.indexOf(':'));
				}

				File f = handleFileUpload(req, item);
				formFields.put(name, f != null ? f.id : null);
				if (f != null) {
					formFields.put(name+".name", f.name);
				}
			}
		}

		req.setAttribute("POST", formFields);
		return formFields;

		} catch (FileUploadException e) {
			throw new ServletException(e);
		}
	}

}
